---
title: 'Stat243: Final Group Project'
author: "Malvika Rajeev, Yihuan Song, RJ Lee"
date: "11/27/2018"
output:
  html_document: default
  pdf_document: default
editor_options: 
  chunk_output_type: console
---
### Library
```{r}
library(tidyverse)
library(AdapSamp)

rpwx <- for piecewise sampling
```

#### Steps

###FUNCTION ARGUMENTS: 


#1. RFUNC.
#2. N : NUMBER OF POINTS NEEDED
#3. (OPTIONAL) STARTINGPOINTS EG C(1,2)
#4. (OPTIONAL) DOMAIN

#for now let's assume the user has input all the arguments. 



a) initialize X_1, ... x_K
      how do we choose k? should be user input, user provide it
    first x_1 : least x for which the derivate at x_1 is positive. fix k. (i.e number of x's.)
      we need x_1 to be as low as possible for which the derivative is positive
        we need to think of a CLEVER FUNCTION DOING THIS
    select x_k: max x for which derivate at x is negative
      uniform spacing using `seq()`
        
b) u_k and then l_k functions
      create functions and then evaluate them
      
c) sample x* from the s_k(x) ; and then w from unif(0, 1)

d) updating step; update T_k as, and then arrange by order; reconstruct u, k, s
  squeeze test


List all the mini-functions that we might need for the ultimate ars() function
also take a look at 


###Sampling
Sample $n$ points independently from f(x) by adaptive rejection sampling using following steps: 

1. Initializing Step

2. Sampling Step

3. Updating Step


1. Initializing Step
```{r}
# D denotes the domain of f(x)
# Choose k starting abscissae
# From pg 342: "In general we have found two starting abscissae (k = 2) to be necessary and sufficient for computational efficiency."



    # need some ways to specify x_1 and x_k
    # better to find x_1 as small as possible as long as derivative is positive and density is positive


#calculate the functions u_k(X), s_k(x) and l_k(x)
    # These are just formula <- just function
   
 
 
 



```

2. Sampling Step
```{r}

# Sample a value x* from s(X)



# Sample a value w independently from the unif(O, 1)



# Squeezing Test 



# Also evaluate (?) h(x*) and h'(x*) <- not sure


```

3. Updating Step
```{r}
#If h(x*) and h'(x*) were evaluated at the sampling step, include x* in Tk to form T_(k+ 1)


#relabel the elements of T_(k+1) in ascending order


#construct the functions U_(k+1)(X), S_(k+1)(x) and I_(k+1)(x)


# Return to the sampling step if n points have not yet been accepted


```

```{r}
### basic function structure
ars <- function(n, f, min, max, sp){
for( i in 1:n){
  
  h <- function(x) log(g(x))
  sp <- sort(sp)
  accept = 0
  sample <- numeric(n)
  
  while(!accept){
    
    t <- fderiv(h, sp, 1)  #h'(x)
    
    #find vector of z
    z <- numeric(length(sp) + 1)
    z[1] <- min
    z[length(z)] <- max
    for(k in 1:(length(z) - 2)){
    z[k+1] <- (h(sp[k+1]) - h(sp[k]) - sp[k+1]*t[k+1] + sp[k]*t[k]) / (t[k] - t[k+1])
    }
    
    # check where of z that x belongs to 
    # now assume x belongs to [zj-1,zj]
    u_func <- function(x, j) h(sp[j]) + (x - sp[j])*t[j] 
    
    # check where of starting points that x belongs to 
    # now assume x belongs to [xj,xj+1]
    # how to adjust so that ifx<x1 orx>xk,lk(x) is set equal to -inf?
    l_func <- function(x, j) ((sp[j+1] - x) * h(sp[j]) + (x - sp[j]) * h(sp[j+1])) / (sp[j+1] - sp[j])
    
    s <- exp(u_func) / integrate(exp(u_func), z[i-1], z[i])
    
    
    u <- runif(1)
    #assume sampled xstar from s(how?)
    
    #squeezing and rejection tests
    ifelse(u <= exp(l(xstar) - u(xstar)), accept = 1, ifelse(u <= exp(h(xstar) - u(xstar)),accept = 1))
    #include xstar in sp
    sp <- sort(c(sp, xstar))
    }
    sample[i] = xstar
  }
  return(sample)
}
```




