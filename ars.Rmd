---
title: 'Stat243: Final Group Project'
author: "Malvika Rajeev, Yihuan Song, RJ Lee"
date: "11/27/2018"
output:
  html_document: default
  pdf_document: default
editor_options: 
  chunk_output_type: console
---
### Library
```{r}
library(tidyverse)
library(AdapSamp)

rpwx <- for piecewise sampling
```

#### Steps

###FUNCTION ARGUMENTS: 


#1. RFUNC.
#2. N : NUMBER OF POINTS NEEDED
#3. (OPTIONAL) STARTINGPOINTS EG C(1,2)
#4. (OPTIONAL) DOMAIN

#for now let's assume the user has input all the arguments. 



a) initialize X_1, ... x_K
      how do we choose k? should be user input, user provide it
    first x_1 : least x for which the derivate at x_1 is positive. fix k. (i.e number of x's.)
      we need x_1 to be as low as possible for which the derivative is positive
        we need to think of a CLEVER FUNCTION DOING THIS
    select x_k: max x for which derivate at x is negative
      uniform spacing using `seq()`
        
b) u_k and then l_k functions
      create functions and then evaluate them
      
c) sample x* from the s_k(x) ; and then w from unif(0, 1)

d) updating step; update T_k as, and then arrange by order; reconstruct u, k, s
  squeeze test


List all the mini-functions that we might need for the ultimate ars() function
also take a look at 


###Sampling
Sample $n$ points independently from f(x) by adaptive rejection sampling using following steps: 

1. Initializing Step

2. Sampling Step

3. Updating Step


1. Initializing Step
```{r}
# D denotes the domain of f(x)
# Choose k starting abscissae
# From pg 342: "In general we have found two starting abscissae (k = 2) to be necessary and sufficient for computational efficiency."



    # need some ways to specify x_1 and x_k
    # better to find x_1 as small as possible as long as derivative is positive and density is positive


#calculate the functions u_k(X), s_k(x) and l_k(x)
    # These are just formula <- just function
   
 
 
 



```

2. Sampling Step
```{r}

# Sample a value x* from s(X)



# Sample a value w independently from the unif(O, 1)



# Squeezing Test 



# Also evaluate (?) h(x*) and h'(x*) <- not sure


```

3. Updating Step
```{r}
#If h(x*) and h'(x*) were evaluated at the sampling step, include x* in Tk to form T_(k+ 1)


#relabel the elements of T_(k+1) in ascending order


#construct the functions U_(k+1)(X), S_(k+1)(x) and I_(k+1)(x)


# Return to the sampling step if n points have not yet been accepted


```

```{r}
### basic function structure
ars <- function(n, f, min, max, sp){
  for( i in 1:n){
    
    h <- function(x) log(g(x))
    sp <- sort(sp)
    accept = 0
    sample <- numeric(n)
    
    while(!accept){
      
      hprime <- function(h, sp) {fderiv(h, sp, 1)  #h'(x)}
      
      #find vector of z
        Z_j <- function(h , hprime, sp, x){
          # docstring
          # Tries to locate z_j's which are points where upper tangent segments
          # intersect with each other
          # h (=ln(g(x))) is the original function and hprime is the first derivative of h
          # x are the sampled points
          
          z <- numeric(length(sp) + 1)
          z[1] <- min
          z[length(z)] <- max
          
          h_e <- h(sp)              # evaluate original function at x
          h_e_1 <- h_e[-1]           # discard first element
          h_e_k <- h_e[-length(sp)]          # discard last element 
          
          hprime_e <- hprime(sp)      # evaluate first derivative function at x
          hprime_e_1 <- hprime_e[-1] # discard first element 
          hprime_e_k <- hprime_e[-length(sp)] # discard last element 
          
          sp_1 <- sp[-1]               # discard first element 
          sp_k <- sp[-length(sp)]               # discard last element
          
          numerator <- h_e_1 - h_e_k - sp_1 * hprime_e_1 + sp_k * hprime_e_k
          denominator <- hprime_e_k - hprime_e_1
          
          z[2:(length(z)-1)] <- numerator/denominator    # formula for z
        
          
          return(z)
        }
      
      for(k in 1:(length(z) - 2)){
        z[k+1] <- (h(sp[k+1]) - h(sp[k]) - sp[k+1]*t[k+1] + sp[k]*t[k]) / (t[k] - t[k+1])
      }
      
      # check where of z that x belongs to 
      # now assume x belongs to [zj-1,zj]
      u_func <- function(x, j) {
        
        h(sp[j]) + (x - sp[j])*t[j] 
      }
      
      # check where of starting points that x belongs to 
      # now assume x belongs to [xj,xj+1]
      # how to adjust so that ifx<x1 orx>xk,lk(x) is set equal to -inf?
      l_func <- function(x, j) ((sp[j+1] - x) * h(sp[j]) + (x - sp[j]) * h(sp[j+1])) / (sp[j+1] - sp[j])
      
      s <- exp(u_func) / integrate(exp(u_func), z[1], z[length(z)])
      
      
      u <- runif(1)
      #assume sampled xstar from s(how?)
      
      #squeezing and rejection tests
      ifelse(u <= exp(l(xstar) - u(xstar)), accept = 1, ifelse(u <= exp(h(xstar) - u(xstar)),accept = 1))
      #include xstar in sp
      sp <- sort(c(sp, xstar))
    }
    sample[i] = xstar
  }
  return(sample)
}
```




