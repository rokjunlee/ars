---
title: 'Stat243: Final Group Project'
author: "Malvika Rajeev, Yihuan Song, RJ Lee"
date: "11/27/2018"
output:
  html_document: default
  pdf_document: default
editor_options: 
  chunk_output_type: console
---
### Library
```{r}
library(tidyverse)
library(AdapSamp)
library(rlang)
library(pracma)
```

#### Steps

###FUNCTION ARGUMENTS: 


#1. RFUNC.
#2. N : NUMBER OF POINTS NEEDED
#3. (OPTIONAL) STARTINGPOINTS EG C(1,2)
#4. (OPTIONAL) DOMAIN

#for now let's assume the user has input all the arguments. 



a) initialize X_1, ... x_K
      how do we choose k? should be user input, user provide it
    first x_1 : least x for which the derivate at x_1 is positive. fix k. (i.e number of x's.)
      we need x_1 to be as low as possible for which the derivative is positive
        we need to think of a CLEVER FUNCTION DOING THIS
    select x_k: max x for which derivate at x is negative
      uniform spacing using `seq()`
        
b) u_k and then l_k functions
      create functions and then evaluate them
      
c) sample x* from the s_k(x) ; and then w from unif(0, 1)

d) updating step; update T_k as, and then arx by order; reconstruct u, k, s
  squeeze test


List all the mini-functions that we might need for the ultimate ars() function
also take a look at 


###Sampling
Sample $n$ points independently from f(x) by adaptive rejection sampling using following steps: 

1. Initializing Step

2. Sampling Step

3. Updating Step


### Auxiliary functions
```{r}
logfunc <- function(func_x){
  # docstring
    # simply 'log's the function that you want
    # func_x is the function that you want to 'log'
  log_func <- function(x) {}
  old_f <- rlang::get_expr(body(func_x))
  body(log_func) <- rlang::get_expr(quo(log(!!old_f)))
  return(log_func)
}

numeric_first_d <- function(f, x){
  # docstring
    # this function numerically calculates first derivative
    # f is the underlying function
    # x is where we want to evaluate
    # below we are taking limit as h goes to 0
  h <- .Machine$double.eps^(1/4)
  numerator <- f(x+h) - f(x)
  denominator <- h
  val <- numerator / denominator
  return(val)
}

numeric_sec_deri <- function(f, x){
  # docstring
    # some functions are hard to derive the second derivative
    # so this calculates second derivative value numerically
    # f is the underlying function
    # x is where we want to evaluate
    # below we are taking limit as h goes to 0
  h <- .Machine$double.eps^0.25
  numerator <- f(x+h) - 2*f(x) + f(x-h)
  denominator <- h^2
  val <- numerator / denominator
  return(val)
}

numeric_sec_deri(logfunc(function(x) dnorm(x)), 38)
```


1. Initializing Step
```{r}

# D denotes the domain of f(x)
# Choose k starting abscissae
# From pg 342: "In general we have found two starting abscissae (k = 2) to be necessary and sufficient for computational efficiency."



    # need some ways to specify x_1 and x_k
    # better to find x_1 as small as possible as long as derivative is positive and density is positive
starting_x <- function(func_x, min_x = -Inf, max_x = Inf){
  # docstring
    # divide into 4 cases
    # 1: both min and max are given
    # 2: when max is finite but min is missing or infinite
    # 3: when min is finite but max is missing or infinite
    # 4: otherwise
  
    # func_x is the underlying function
    # min_x and max_x are min and max of f's domain
  
  
  # First case
  if (is.finite(min_x) && is.finite(max_x)){ # case when max and min of x are given and FINITE
    
    return(c(min_x, max_x))  # simplest case: just return min and max values
  
  # Second case  
  } else if ( (is.infinite(min_x) == TRUE || is.na(min_x)==TRUE)  # min is missing or infinte
              && is.finite(max_x) == TRUE ) { # max is finite
    
    if (numeric_first_d(function(x) func_x(x), -.Machine$integer.max) > 0){
      min_x <- -.Machine$integer.max # if derivative is positive then just use -.Machine$integer.max
    } else { # otherwise slowly increase min_x until it becomes positive
      min_x <- -1000  
      while (numeric_first_d(function(x) func_x(x), min_x) <= 0) { 
        #print(numeric_first_d(function(x) func_x(x), min_x))
        min_x <- min_x + 5
        }
    }
    return(c(min_x, max_x))
    
    
  # Third case
  } else if ( (is.infinite(max_x) == TRUE || is.na(max_x)==TRUE) # max is missing or infinite
              && is.finite(min_x)==TRUE ) {  # min is finite
    
    if (numeric_first_d(function(x) func_x(x), .Machine$integer.max) < 0){
      max_x <- .Machine$integer.max # if derivative is negative then just use .Machine$integer.max
    } else {  # otherwise slowly decrease max_x until it becomes negative
      max_x <- 1000
      while (numeric_first_d(function(x) func_x(x), max_x) >= 0) {
        #print(numeric_first_d(function(x) func_x(x), max_x))
        max_x <- max_x - 5
      }
    }
    return(c(min_x, max_x))
  
  # Fourth case
  } else {  # both min and max are infinite or both missing
    
    if (numeric_first_d(function(x) func_x(x), -.Machine$integer.max) > 0){
      min_x <- -.Machine$integer.max
    } else {
      min_x <- -1000
      while (numeric_first_d(function(x) func_x(x), min_x) <= 0) {
        #print(numeric_first_d(function(x) func_x(x), min_x))
        min_x <- min_x + 5
      }
    }
    
    if (numeric_first_d(function(x) func_x(x), .Machine$integer.max) < 0){
      max_x <- .Machine$integer.max
    } else {
      max_x <- 1000
      while (numeric_first_d(function(x) func_x(x), max_x) >= 0) {
        #print(numeric_first_d(function(x) func_x(x), max_x))
        max_x <- max_x - 5
      }
    }
    return(c(min_x, max_x))   
    
  }
}

```


```{r}
### basic function structure
ars <- function(n, f, min, max, sp = NA){
    
    
    if (n <= 0 || !is.numeric(n)) 
      stop("Please enter positive integers for sample size.")
    if (min >= max || !is.numeric(min) || !is.numeric(max) ) 
      stop("Please input valid domain.")
  
    c <- integrate(f, min, max)$value #normalizing constant
    g_func <- function(f, x){
        # docstring:
        # f is the underlying density function
        # left_b and right_b are lower and upper bound, respectively
        # x is where you want to evaluate
        # after calculating the normalizing constant c  
        # this function simply creates g as described in the paper
        g <- f(x) / c
        return(g)
      }
      
      h <- function(x) {log(g_func(f,x))}
      dh <- function(x) {numeric_first_d(h, x)}   

      if(is.na(sp)) {sp = starting_x(f, min, max)}
      if( prod(dh(sp)) > 0 ) {stop("Starting points must be in opposite sides the maximum")}
      sp <- sort(sp)
      sample <- numeric(n)
     
      u_func = function(x, sp) 
      {
        # docstring
        # function calculates the upper hull piece corresponding to 
        # the data sampled from Sk
        # sp is the starting points
        # x is the sampled point
        z <- numeric(length(sp) + 1)
        z[1] <- min
        z[length(z)] <- max
        z_middle <- sort(z(sp))
        z[2:(length(z)-1)] <- z_middle
        index = findInterval(x, z)
        u <- h(sp[index]) + (x - sp[index])*dh(sp[index])
        return(u)
      }
      
      l_func <- function(x, sp) {
        # docstring
        # function calculates the lower hull piece corresponding to 
        # the data sampled from Sk, set to -inf if x<x1 or x>xk
        # sp is the starting points
        # x is the sampled point
        index <- findInterval(x, c(min, sp, max))
        l <- 0
        
        if (x <= sp[(length(sp))] & x >= sp[1]){
          l<- ((sp[index] - x) * h(sp[index - 1]) + (x - sp[index - 1]) * h(sp[index])) / 
            (sp[index] -sp[index - 1])} 
        else{
            l<- -Inf
          }
        return(l)
      }
      
      z <- function(support)
      {
        x0 <- head(support, n=-1)
        x1 <- tail(support, n=-1)
        zed <- x0 + (h(x0) - h(x1) + (x1 - x0)*dh(x1)) / (dh(x1) - dh(x0))
        return(zed)	
      }
      
     u_k = function(y, support) 
{
  u_plus = rep(0, length(y))
  zed = z(support)
  
  piecewise.idx = findInterval(y, c(min, zed, max))
  npieces = length(zed) + 2
  for(pidx in 1:npieces){
    yp = y[piecewise.idx == pidx]
    xx = h(support[pidx]) + (yp - support[pidx])*dh(support[pidx])
    u_plus[piecewise.idx == pidx] = xx
  }
  return(u_plus)
}

plus.cdf = function(x, sp) 
{

  
  zed = z(sp)
  
  zlen = length(zed) ##NUMBER OF CDF POINTS
  s_k_cdf = numeric(length(x))
  normaliser = 0
  for(i in 0:zlen) {
    if(i == 0)
    {
      z_lower = -Inf
    } else {
      z_lower = zed[i]
    }
    
    if(i == zlen)
    {
      z_upper = Inf
    } else {
      z_upper = zed[i+1]
    }
    
    x_j = sp[i+1]
    ds = exp(h(x_j))/dh(x_j) * ( exp((z_upper - x_j)*dh(x_j)) - exp((z_lower - x_j)*dh(x_j)) )
    
    lower_int = z_lower < x & x <= z_upper ##which zj's are lower x
    upper_int = x > z_upper ##which interval does x lie in
    
    s_k_cdf[lower_int] = s_k_cdf[lower_int] + exp(h(x_j))/dh(x_j) * ( exp((x[lower_int] - x_j)*dh(x_j)) - exp((z_lower - x_j)*dh(x_j)) )
    s_k_cdf[upper_int] = s_k_cdf[upper_int] + ds
    
    normaliser = normaliser + ds
  }
  
  l = list( 
    s_k_cdf = s_k_cdf / normaliser, 
    normaliser = normaliser
  )
  return(l)
}


 s_k_sample = function(support)
    {
      zed = z(support)
      sp = plus.cdf(zed, support)
      zpct = sp$required_cdf
      normaliser = sp$normaliser
      ub = c(0, zpct, 1)
      
      unif.samp = runif(1)
      
      fidx = findInterval(unif.samp, ub)
      num.intervals = length(ub) - 1
      zlow = c(min, zed)
      res = rep(0, length(unif.samp))
      for(i in 1:num.intervals)
      {
        ui = unif.samp[ fidx == i ]
        
        if(length(ui) == 0)
        {
          next
        }
        
        ## Invert the  CDF
        yp = support[i]
        zm = zlow[i]
        tmp = (ui - ub[i]) * dh(yp) * normaliser / exp(h(yp)) + exp( (zm - yp)*dh(yp) )
        tmp = yp + log(tmp) / dh(yp)
        res[ fidx == i ] = tmp
      }
      return(res)
 }
 #check logconcave

logconcav_check <- function(sp){ #x is starting points given
  # docstring
  # This function finds out numerical value of the second derivative
  # at x of the function 
  # if all of the numerical values are negative, then this function
  # tells us that the func is log concave. vice versa
  sp[length(sp)] <- sp[length(sp)] - 1
  x_1 <- sp[-1]
  x_0 <- sp[-length(sp)]
  result <- dh(x_1) - dh(x_0)
  result[which(is.nan(result))] = -Inf
  l <- 0
  if (max(result) <= 0) {     # if max is less than zero, then all are
    l <- TRUE
  } else {                   # case one or more second derivative evaluation is positive
    l <- FALSE
  }
  return(l)
}


##begin sampling
      
      for( i in 1:n){
        
        accept = 0
        check = 0
        while(!accept){
          
          u <- runif(1)
          xstar <- s_k_sample(sp)
          
          #squeezing and rejection tests
          if (u <= exp(l_func(xstar, sp) - u_func(xstar, sp))) { 
            accept = 1 
          } else if (u <= exp(h(xstar) - u_func(xstar, sp))) { 
            accept = 1 
            #include xstar in sp
            sp <- sort(c(sp, xstar))
            check <- logconcav_check(sp)
           if (!check) { stop("The function isn't log concave. Please input a log concave function")}
            }
        }
        sample[i] = xstar
      }
      return(sample)
    }



# Checking
ars(10, f = function(x) dnorm(x, 2), -10, 10, c(-2, 3))
ars(10, f = function(x) dnorm(x, -1), -10, 10, c(-2, 1))
ars(10, f = function(x) dnorm(x,-5), -10, 10, c(-8, 2)) #slow
ars(20, f = function(x) dnorm(x,5), -10, 10, c(-1, 7))
#ars(20, f = function(x) dnorm(x), -20, 30, c(-19, 1)) #slow
ars(20, f = function(x) dgamma(x, 5), 0, 10, c(2,5))
ars(20, f = function(x) dbeta(x,2,2), 0, 1, c(0.1,0.6))

# not working 
ars(20, f = function(x) x^2, -100, 100, c(-2,10)) #xstar is NaN in this case

# non log concave function input
ars(20, f = function(x) dt(x,3), -100, 100, c(-2,10)) # gives us the correct error

#user not give or give inf as sp
ars(10, f = function(x) dnorm(x), -10, 10) #infinite loop, xstar never accepted
#> f<-function(x) dnorm(x)
#> starting_x(f)
#[1] -35  35
#but in this case, (sum(is.finite(sp)) < length(sp)) { sp = starting_x(f, min, max)}) gives starting points of (-10,10)


#timing
system.time(ars(1000, f = function(x) dnorm(x, 2), -10, 10, c(-2, 3)))
 #  user  system elapsed 
 # 6.803   0.101   6.906 
```




