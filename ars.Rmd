---
title: 'Stat243: Final Group Project'
author: "Malvika Rajeev, Yihuan Song, RJ Lee"
date: "11/27/2018"
output:
  html_document: default
  pdf_document: default
editor_options: 
  chunk_output_type: console
---
### Library
```{r}
library(tidyverse)
library(AdapSamp)

rpwx <- for piecewise sampling
```

#### Steps

###FUNCTION ARGUMENTS: 


#1. RFUNC.
#2. N : NUMBER OF POINTS NEEDED
#3. (OPTIONAL) STARTINGPOINTS EG C(1,2)
#4. (OPTIONAL) DOMAIN

#for now let's assume the user has input all the arguments. 



a) initialize X_1, ... x_K
      how do we choose k? should be user input, user provide it
    first x_1 : least x for which the derivate at x_1 is positive. fix k. (i.e number of x's.)
      we need x_1 to be as low as possible for which the derivative is positive
        we need to think of a CLEVER FUNCTION DOING THIS
    select x_k: max x for which derivate at x is negative
      uniform spacing using `seq()`
        
b) u_k and then l_k functions
      create functions and then evaluate them
      
c) sample x* from the s_k(x) ; and then w from unif(0, 1)

d) updating step; update T_k as, and then arrange by order; reconstruct u, k, s
  squeeze test


List all the mini-functions that we might need for the ultimate ars() function
also take a look at 


###Sampling
Sample $n$ points independently from f(x) by adaptive rejection sampling using following steps: 

1. Initializing Step

2. Sampling Step

3. Updating Step


1. Initializing Step
```{r}
# D denotes the domain of f(x)
# Choose k starting abscissae
# From pg 342: "In general we have found two starting abscissae (k = 2) to be necessary and sufficient for computational efficiency."



    # need some ways to specify x_1 and x_k
    # better to find x_1 as small as possible as long as derivative is positive and density is positive


#calculate the functions u_k(X), s_k(x) and l_k(x)
    # These are just formula <- just function
   
 
 
 



```

2. Sampling Step
```{r}

# Sample a value x* from s(X)



# Sample a value w independently from the unif(O, 1)



# Squeezing Test 



# Also evaluate (?) h(x*) and h'(x*) <- not sure


```

3. Updating Step
```{r}
#If h(x*) and h'(x*) were evaluated at the sampling step, include x* in Tk to form T_(k+ 1)


#relabel the elements of T_(k+1) in ascending order


#construct the functions U_(k+1)(X), S_(k+1)(x) and I_(k+1)(x)


# Return to the sampling step if n points have not yet been accepted


```

```{r}
### basic function structure
ars <- function(n, f, min, max, sp){
  
  g_func <- function(input_func, x){
    # docstring:
    # input_func is the underlying density function
    # x is where you want to evaluate
    # after calculating the normalizing constant c  
    # this function simply creates g as described in the paper
    
    c <- integrate(input_func, min, max)$value #normalizing constant
    g <- c * input_func(x)
    return(g)
  }
  
  h <- function(x) log(g_func(f, x))
  dh <- function(x) {fderiv(h, x, 1)} #h'(x)
  
  sp <- sort(sp)
  sample <- numeric(n)
  
    for( i in 1:n){
  
      accept = 0
      
      while(!accept){
        
        #find vector of z
        Z <- function(sp){
          # docstring
          # Tries to locate z_j's which are points where upper tangent segments
          # intersect with each other, with z0 set as min and zk set as max
          # sp are the starting points
          
          z <- numeric(length(sp) + 1)
          z[1] <- min
          z[length(z)] <- max
          
          h_e <- h(sp)              # evaluate original function at x
          h_e_1 <- h_e[-1]           # discard first element
          h_e_k <- h_e[-length(sp)]          # discard last element 
          
          hprime_e <- dh(sp)      # evaluate first derivative function at x
          hprime_e_1 <- hprime_e[-1] # discard first element 
          hprime_e_k <- hprime_e[-length(sp)] # discard last element 
          
          sp_1 <- sp[-1]               # discard first element 
          sp_k <- sp[-length(sp)]               # discard last element
          
          numerator <- h_e_1 - h_e_k - sp_1 * hprime_e_1 + sp_k * hprime_e_k
          denominator <- hprime_e_k - hprime_e_1
          
          z[2:(length(z)-1)] <- numerator/denominator    # formula for z
          
          
          return(z)
        }
        
        
        u_func = function(x, sp) 
        {
          # docstring
          # function calculates the upper hull piece corresponding to 
          # the data sampled from Sk
          # sp is the starting points
          # x is the sampled point
          z <- sort(Z(sp))
          index = findInterval(x, z)
          u <- h(sp[index]) + (x - sp[index])*dh(sp[index])
          return(u)
        }
        
        
        l_func <- function(x, sp) {
          # docstring
          # function calculates the lower hull piece corresponding to 
          # the data sampled from Sk, set to -inf if x<x1 or x>xk
          # sp is the starting points
          # x is the sampled point
          index <- findInterval(x, c(min, sp, max))
          
          if (x <= sp[(length(sp))] & x >= sp[1]){
            l<- ((sp[index] - x) * h(sp[index - 1]) + (x - sp[index - 1]) * h(sp[index])) / (sp[index] - sp[index - 1])} else{
              l<- -Inf
            }
          
        }
        
        
        
        u <- runif(1)
        #assume sampled xstar from s(how?)
        
        #squeezing and rejection tests
        if(u <= exp(l_func(xstar, sp) - u_func(xstar, sp))) { accept = 1 } 
           else if (u <= exp(h(xstar) - u_func(xstar, sp))) { 
             accept = 1 
        #include xstar in sp
        sp <- sort(c(sp, xstar))}
      }
      sample[i] = xstar
    }
    return(sample)
}
```




