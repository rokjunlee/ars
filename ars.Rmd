---
title: 'Stat243: Final Group Project'
author: "Malvika Rajeev, Yihuan Song, RJ Lee"
date: "11/27/2018"
output:
  html_document: default
  pdf_document: default
editor_options: 
  chunk_output_type: console
---
### Library
```{r}
library(AdapSamp)
library(rlang)
library(pracma)
```

#### Steps

###FUNCTION ARGUMENTS: 


#1. RFUNC.
#2. N : NUMBER OF POINTS NEEDED
#3. (OPTIONAL) STARTINGPOINTS EG C(1,2)
#4. (OPTIONAL) DOMAIN

#for now let's assume the user has input all the arguments. 



a) initialize X_1, ... x_K
      how do we choose k? should be user input, user provide it
    first x_1 : least x for which the derivate at x_1 is positive. fix k. (i.e number of x's.)
      we need x_1 to be as low as possible for which the derivative is positive
        we need to think of a CLEVER FUNCTION DOING THIS
    select x_k: max x for which derivate at x is negative
      uniform spacing using `seq()`
        
b) u_k and then l_k functions
      create functions and then evaluate them
      
c) sample x* from the s_k(x) ; and then w from unif(0, 1)

d) updating step; update T_k as, and then arx by order; reconstruct u, k, s
  squeeze test


List all the mini-functions that we might need for the ultimate ars() function
also take a look at 


###Sampling
Sample $n$ points independently from f(x) by adaptive rejection sampling using following steps: 

1. Initializing Step

2. Sampling Step

3. Updating Step


### Auxiliary functions
```{r}
logfunc <- function(func_x){
  # docstring
    # simply 'log's the function that you want
    # func_x is the function that you want to 'log'
  log_func <- function(x) {}
  old_f <- rlang::get_expr(body(func_x))
  body(log_func) <- rlang::get_expr(quo(log(!!old_f)))
  return(log_func)
}

numeric_first_d <- function(f, x){
  # docstring
    # this function numerically calculates first derivative
    # f is the underlying function
    # x is where we want to evaluate
    # below we are taking limit as h goes to 0
  h <- .Machine$double.eps^(1/4)
  numerator <- f(x+h) - f(x)
  denominator <- h
  val <- numerator / denominator
  return(val)
}

numeric_sec_deri <- function(f, x){
  # docstring
    # some functions are hard to derive the second derivative
    # so this calculates second derivative value numerically
    # f is the underlying function
    # x is where we want to evaluate
    # below we are taking limit as h goes to 0
  h <- .Machine$double.eps^0.25
  numerator <- f(x+h) - 2*f(x) + f(x-h)
  denominator <- h^2
  val <- numerator / denominator
  return(val)
}

```


1. Initializing Step
```{r}

# D denotes the domain of f(x)
# Choose k starting abscissae
# From pg 342: "In general we have found two starting abscissae (k = 2) to be necessary and sufficient for computational efficiency."



    # need some ways to specify x_1 and x_k
    # better to find x_1 as small as possible as long as derivative is positive and density is positive
starting_x1 <- function(func_x, min_x, max_x){
  # First case
  if (is.finite(min_x) && is.finite(max_x)){ # case when max and min of x are given and FINITE
    opt <- optimize(function(x) func_x(x), 
                    c(min_x, max_x), 
                    maximum = TRUE)$maximum
    left <- quantile(c(min_x, opt, max_x), 0.49) %>% as.vector()
    right <- quantile(c(min_x, opt, max_x), 0.51)%>% as.vector()
    return(c(left, right))
    
    # Second case  
  } else if ( (is.infinite(min_x) == TRUE || is.na(min_x)==TRUE)  # min is missing or infinte
             && is.finite(max_x) == TRUE ) {
    min_x <- -100
    opt <- optimize(function(x) func_x(x), 
           c(min_x, max_x), 
           maximum = TRUE)$maximum
  left <- quantile(c(min_x, opt, max_x), 0.49) %>% as.vector()
  right <- quantile(c(min_x, opt, max_x), 0.51) %>% as.vector()
  return(c(left, right))
  } else if ( (is.infinite(max_x) == TRUE || is.na(max_x)==TRUE) # max is missing or infinite
              && is.finite(min_x)==TRUE ) {
    max_x <- 100
    opt <- optimize(function(x) func_x(x), 
                    c(min_x, max_x), 
                    maximum = TRUE)$maximum
    left <- quantile(c(min_x, opt, max_x), 0.49) %>% as.vector()
    right <- quantile(c(min_x, opt, max_x), 0.51) %>% as.vector()
    return(c(left, right))
  } else {
    max_x <- 100
    min_x <- -100
    opt <- optimize(function(x) func_x(x), 
                    c(min_x, max_x), 
                    maximum = TRUE)$maximum
    left <- quantile(c(min_x, opt, max_x), 0.49) %>% as.vector()
    right <- quantile(c(min_x, opt, max_x), 0.51) %>% as.vector()
    return(c(left, right))
  }
}

```


```{r}
### basic function structure
ars <- function(n, f, min, max, sp = NA){
  
  
  
  if (n <= 0 || !is.numeric(n)) 
    stop("Please enter positive integers for sample size.")
  if (min >= max || !is.numeric(min) || !is.numeric(max) ) 
    stop("Please input valid domain.")
  
  g_func <- function(f, x){
    # docstring:
    # f is the underlying density function
    # left_b and right_b are lower and upper bound, respectively
    # x is where you want to evaluate
    # after calculating the normalizing constant c  
    # this function simply creates g as described in the paper
    
    c <- integrate(f, min, max)$value #normalizing constant
    g <- f(x) / c
    return(g)
  }
  
  h <- function(x) {log(g_func(f,x))}
  dh <- function(x) {fderiv(h, x, 1)}   
  if(sum(is.finite(sp)) < length(sp)) {sp = starting_x1(f, min, max)}
  if( prod(dh(sp)) > 0 ) {stop("Starting points must be in opposite sides the maximum")}
  sp <- sort(sp)
  sample <- numeric(n)
  
  u_func = function(x, sp) 
  {
    # docstring
    # function calculates the upper hull piece corresponding to 
    # the data sampled from Sk
    # sp is the starting points
    # x is the sampled point
    z <- numeric(length(sp) + 1)
    z[1] <- min
    z[length(z)] <- max
    z_middle <- sort(z(sp))
    z[2:(length(z)-1)] <- z_middle
    index = findInterval(x, z)
    u <- h(sp[index]) + (x - sp[index])*dh(sp[index])
    return(u)
  }
  
  l_func <- function(x, sp) {
    # docstring
    # function calculates the lower hull piece corresponding to 
    # the data sampled from Sk, set to -inf if x<x1 or x>xk
    # sp is the starting points
    # x is the sampled point
    index <- findInterval(x, sp)
    l <- 0
    if (index == 0 | index == length(sp) ){
      l <- -Inf}
    else {
      l<- ((sp[index + 1] - x) * h(sp[index]) + (x - sp[index]) * h(sp[index + 1])) / 
        (sp[index + 1] -sp[index])} 
    
    return(l)
  }
  
  z <- function(support)
  {
    x0 <- head(support, n=-1)
    x1 <- tail(support, n=-1)
    zed <- x0 + (h(x0) - h(x1) + (x1 - x0)*dh(x1)) / (dh(x1) - dh(x0))
    return(zed)	
  }
  
  u_k = function(y, support) 
  {
    u_plus = rep(0, length(y))
    zed = z(support)
    
    piecewise.idx = findInterval(y, c(min, zed, max))
    npieces = length(zed) + 2
    for(pidx in 1:npieces){
      yp = y[piecewise.idx == pidx]
      xx = h(support[pidx]) + (yp - support[pidx])*dh(support[pidx])
      u_plus[piecewise.idx == pidx] = xx
    }
    return(u_plus)
  }
 
 ##'docstring
##'for each starting points, we calculate the value of cdf from zi to zi+1. 
##'we store this as a list, each element corresponding to the cdf of that interval.
##'we normalise the cdf by dividing by its sum.
  
plus.cdf <- function(sp) 
{
  
  zed = c(min,z(sp),max)
  l = length(zed) - 1
  cdf_vals = numeric(l)
  
  for (i in 1:l) {
    x_j = sp[i]
    cdf_vals[i] = exp(h(x_j))/dh(x_j) * ( exp((zed[i+1] - x_j)*dh(x_j)) - exp((zed[i] - x_j)*dh(x_j)) )}
  
    normaliser <- sum(cdf_vals)
   return(cdf_vals/normaliser)
}

##'docstring
##'sampling from cdf: we pick the cdf interval from which to sample from with probability equal to its value
##'then we sample a point from that interval uniformly.

s_k_sample <- function(sp) {
  probs <- plus.cdf(sp)
  which_bin <- sample(length(sp), size = 1, prob = probs)
  sample <- runif(1, min = 0, max = probs[which_bin])
  return(sample)
}
  #check logconcave
  logconcav_check <- function(sp){ #x is starting points given
    # docstring
    # This function finds out numerical value of the second derivative
    # at x of the function 
    # if all of the numerical values are negative, then this function
    # tells us that the func is log concave. vice versa
    x_1 <- sp[-1]
    x_0 <- sp[-length(sp)]
    result <- dh(x_1) - dh(x_0)
    result[which(is.nan(result))] = -Inf
    l <- 0
    if (max(result) <= 0) {     # if max is less than zero, then all are
      l <- TRUE
    } else {                   # case one or more second derivative evaluation is positive
      l <- FALSE
    }
    return(l)
  }
  ##begin sampling
  
  for( i in 1:n){
    
    accept = 0
    check = 0
    while(!accept){
      
      u <- runif(1)
      xstar <- s_k_sample(sp)
      
      #squeezing and rejection tests
      if (u <= exp(l_func(xstar, sp) - u_func(xstar, sp))) { 
        accept = 1 
      } else if (u <= exp(h(xstar) - u_func(xstar, sp))) { 
        accept = 1 
        #include xstar in sp
        sp <- sort(c(sp, xstar))
        check <- logconcav_check(sp)
        if (!check) { stop("The function isn't log concave. Please input a log concave function")}
      }
    }
    sample[i] = xstar
  }
  return(sample)
  
}



# Checking
ars(10, f = function(x) dnorm(x, 2), -10, 10, c(-2, 3))
ars(10, f = function(x) dnorm(x, -1), -10, 10, c(-2, 1))
ars(10, f = function(x) dnorm(x,-5), -10, 10, c(-8, 2)) #slow
ars(20, f = function(x) dnorm(x,5), -10, 10, c(-1, 7))
#ars(20, f = function(x) dnorm(x), -20, 30, c(-19, 1)) #slow
ars(20, f = function(x) dgamma(x, 5), 0, 10, c(2,5))
ars(20, f = function(x) dbeta(x,2,2), 0, 1, c(0.1,0.6))

# not working 
ars(20, f = function(x) x^2, -100, 100, c(-2,10)) #xstar is NaN in this case

# non log concave function input
ars(20, f = function(x) dt(x,3), -100, 100, c(-2,10)) # gives us the correct error

#user not give or give inf as sp
ars(10, f = function(x) dnorm(x), -10, 10) #infinite loop, xstar never accepted
#> f<-function(x) dnorm(x)
#> starting_x(f)
#[1] -35  35
#but in this case, (sum(is.finite(sp)) < length(sp)) { sp = starting_x(f, min, max)}) gives starting points of (-10,10)


#timing
system.time(ars(1000, f = function(x) dnorm(x, 2), -10, 10, c(-2, 3)))
 #  user  system elapsed 
 # 6.803   0.101   6.906 


# Checking with graph 
samples <- ars(1000, f = function(x) dnorm(x, 2), -Inf, Inf, c(1, 3))
hist(samples, breaks = 100)
f = function(x) dnorm(x, 2)
curve(f, add = T)


```




